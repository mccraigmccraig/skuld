#+title: Algebraic Effects in Elixir

* What are Algebraic Effects
- Allow *pure* programs to *describe* the side-effects they need
  without specifying how they are to be achieved
- A mechanism for descriptions of side-effects to be interpreted
  different ways
- The descriptions of side-effects are values in algebras formed
  by effect operations - similar to fields in arithmetic

* Why
- most programs have some pure functions and some side-effecting functions.
  The pure parts of the program are nicer to work with, and one would generally
  like to make as much of the program pure as possible
- Patterns such as functional-core/imperative-shell aim in this dirextion
  - the pattern is easy enough initially, but gets hard as call
    stacks get deeper and effect dependencies compound

- Algebraic Effects ntroduce some useful additional structure to programs
  1. fully pure functions remain
     - not much change here
  2. effectful functions are introduced
     - these are new, and most of the previously side-effecting functions in a
       program can be replaced with effectful functions. Effectful functions
       compose sequences of "effects" - which are function calls without any
       specified implementation. Implementation is provided by handlers, and
       can be changed for different contexts - e.g. a pure implementation to
       run in test contexts without a database
  3. impure effect handlers - the small parts of the program which truly need
     to be impure - because they do I/O or deal with randomness or async &c -
     are relegated to effect handlers
     - effect handlers are thin, easily testable, wrappers for side-effecting
        plumbing

* Where
- I/O bound programs struggling to manage complexity
- CSV importer
- combination of Reader / Writer pattern + CommandStreams

* The cost
- Freyja is slow - benchmarked at 17x slower than a simple state monad for
  in-memory computation
- Skuld is cobsiderably faster - 4x slower than a simple state monad
  - this seems reasonable for heavily I/O bound processes. A Benchmark with the
    user.csv importer shows an N times speedup because bulk data access is used
    - the thing that Algebraic Effects bring is making the bulk code as easy to
      write as the slow N+1 pattern code

* Aliases
- use these aliassa to run all the code examples in IEx

#+begin_src elixir
alias Freyja.Freer
alias Freyja.Hefty
alias Freyja.Run
alias Freyja.Effects.Reader
alias Freyja.Effects.Writer
alias Freyja.Effects.State
alias Freyja.Effects.TaggedWriter
alias Freyja.Effects.Lift
alias Freyja.Effects.FxList
alias Freyja.Effects.Throw
alias Freyja.Effects.Catch
alias Freyja.Effects.Else
alias Freyja.Effects.EffectLogger
require Integer
use Freyja.Syntax
#+end_src

* Effect signatures
- Here's a few simple foundational effect signatures
- each Effect signature defines one or more operations in the effect,
  and each operation signifies a request for some value without
  specfying how that value is to be obtained.
- in Freyja, each operation function creates a simple data structure,
  detailing the request, and wraps it in a Freer structure...

** Reader
pure functions can ask for a value anywhere in the call stack without
additional params
  - values can be system-wide config, or operation-specific config

#+begin_src elixir
defmodule Freyja.Effects.Reader do
  defstruct Ask
  def ask, do: %Ask{} |> Freer.send_effect()
end
#+end_src

** Writer
pure functions can accumluate values to a log from anywhere in the call stack,
without accumulator params
 - capture changes from deep within a call stack

#+begin_src elixir
defmodule Freyja.Effects.Writer do
  defstruct Tell, val: nil
  def tell(v), do: %Tell{val: v} |> Freer.send_effect()
end
#+end_src

** State
pure functions can maniuplate a state variable from anywhere in the call stack,
without additional params
  - state could come from memory, database, cache - anywhere

#+begin_src elixir
defmodule Freyja.Effects.State do
  defstruct Get
  def get, do: %Get{} |> Freer.send_effect()

  defstruct Put, val: nil
  def put(v), do: %Put{val: v} |> Freer.send_effect()
end
#+end_src

** what does send_effect do ?
In Freyja, the operation functions wrap data structures describing an effect
request in a Freer type, which has two structs

*** Pure
represents a terminal node in a computation - just a value, which does
not require any further interpretation
#+begin_src elixir
  defmodule Freyja.Freer.Pure do
    defstruct val: nil
  end
#+end_src

*** Impure
represents a non-termiinal node in a computation - it requires
interpretation for the computation to proceed
#+begin_src elixir
  defmodule Freyja.Freer.Impure do
    defstruct sig: nil, data: nil, q: []
  end
#+end_src

- sig: an effect signature module atom
- data: an effect operation data structure, liks `%Ask{}`
- q: a queue of `(term -> Freer.t())` continuations to feed
  interpreted effect opeation values to

*** The interpreter
The job of the interpreter is to interpret (aka handle) all effects
in Impure nodes in a computation, until only a Pure node remains, which
that will contain the result of the computation

*** send_effect
- `send_effect` wraps a data-structure describing an effect request into
  a minimal `Impure` struct - the continuation queue consists of just
  `&Freer.pure/1`, which returns a value in a `Freer.Pure` terminal node.
- because it's wrapped in `Impure` the effect operation struct is marked
  as being non-terminal, or requiring interpreting, but once it's been
  interpreted (by a handler) the `&Freer.pure/1` continuation immediately
  returns the interpreted value in a terminal node

#+begin_src elixir
Reader.ask()

# %Freyja.Freer.Impure{
#   sig: Freyja.Effects.Reader,
#   data: %Freyja.Effects.Reader.Ask{},
#   q: [&Freyja.Freer.pure/1]
# }

State.put(100)

# %Freyja.Freer.Impure{
#   sig: Freyja.Effects.State,
#   data: %Freyja.Effects.State.Put{val: 100},
#   q: [&Freyja.Freer.pure/1]
# }

#+end_src


* How can we use effects
- some simple example Freyja code introducing how
  effects can be combined into programs

** we can "handle" an effect
- Handlers provide an interpreter for a particular effect's operations

#+begin_src elixir
   Reader.ask()
   |> Reader.Handler.run(42)
   |> Run.eval()

#>   42

#+end_src

** We can sequence and compose effect operations
using values from previous effects to request new effects

We use the `&Freer.bind/2` function, which takes a Freer computation,
and a function `(term -> freer)` of an interpreted effect value which
returns another Freer - you'll see why the function is called `bind`
soon. We also use `&Freer.return/1` which returns a value in a
terminal node Freer.Pure struct

This computation requests two effects before returning a result:

#+begin_src elixir
Freer.bind(
  Reader.ask(),
  fn x ->
    Freer.bind(
      State.get(),
      fn y -> Freer.return(x + y) end)
  end)
  |> Reader.Handler.run(5)
  |> State.Handler.run(10)
  |> Run.eval()

#>   15

#+end_src

but this looks pretty ugly, and the nesting makes it hard to see what's going on...

** so, with a little macro sugar
This code is exactly equivalent to the previous sequence of nested
function calls, and makes the intent much clearer - the bound/matched
forms on the left of `<-` expressions end up as the anonymous function
parameters of the same name above, so the `con` block behaves like
a generalized `with` - binding (hence the name) interpreted effect
values to variables at each step

#+begin_src elixir
con do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end
|> Reader.Handler.run(5)
|> State.Handler.run(10)
|> Run.eval()

#>    15

#+end_src


* So what's actually going on here
- let's manually play the interpreter so we can see how this works

#+begin_src elixir
e = con do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end

# %Freyja.Freer.Impure{
#   sig: Freyja.Effects.Reader,
#   data: %Freyja.Effects.Reader.Ask{},
#   q: [&Freyja.Freer.pure/1, #Function<42.113135111/1 in :erl_eval.expr/6>]
# }

#+end_src

** the `con` expression creates an `Freer.Impure` struct
which has 3 fields
- `sig` - the effect signature atom
- `data` - the struct returned by an operation function from the effect signature module
- `q` - a queue of continuations to feed resolved effect values to - the first
  item on the queue is `&Freer.pure/1` which is from the `Freer.send_effect` in
  the effect signature opeation. The second item on the queue is the anonymous
  function from the second parameter of the `bind` call, which binds the `x`
  parameter

** if we manually feed values to the continuations
playing the part of the interpreter, we can see how the computation
evolves to completion...

so if we call the second continuation with the value 5, we are setting the
value of `x`, the response to the Ask request, to 5 (the same value
used before)...

#+begin_src elixir
cont = e.q |> Enum.at(1)
e2 = cont.(5)

# %Freyja.Freer.Impure{
#   sig: Freyja.Effects.State,
#   data: %Freyja.Effects.State.Get{},
#   q: [&Freyja.Freer.pure/1, #Function<42.113135111/1 in :erl_eval.expr/6>]
# }

#+end_src

and we get a new `Impure` struct returned, with `data` for the `State.get()`
operation...

** calling the second continuation with the value 10
is saying that the `State.get()` operation yielded 10 - which becomes
the value of `y`...

#+begin_src elixir
cont2 = e2.q |> Enum.at(1)
cont2.(10)

# %Freyja.Freer.Pure{val: 15}
#+end_src

** and we have arrived
we get a `Pure` struct back, wihch represents a terminal
node in a computaiton, with value `15` - from `x + y`


** What have we seen
- the `con` macro rearranges a `with`-like syntax into nested
  `bind` function calls
- program logic is captured in *pure* continuations in the `Freer.Impure` struct
- pure program logic can use effect operations to make impure requests
- handlers can interpret those requests however they like

* getting more real-world

- introducing some new concepts

** defcon
the `con` macro makes sequencing effect requests into a computation easy.
`defcon` does the same for functions

#+begin_src elixir
defmodule Ex1 do

  defcon foo(x) do
    y <- Reader.ask()
    return(x + y)
  end

end

Ex1.foo(5)
|> Reader.Handler.run(10)
|> Run.eval()
#+end_src

** turtles

#+begin_src elixir
defmodule Ex2 do

  defcon bar(x) do
    z <- Ex1.foo(x)
    return(z)
  end

end

Ex2.bar(5)
|> Reader.Handler.run(10)
|> Run.eval()
#+end_src

** higher and higher

So far, we've only seen "first order" effects - effects which *do not* take
computations as parameters... but there are higher-order effects which *do* take
computations as parameters too.

When there are higher-order effects in
play we use `hefty` blocks and `defhefty` functions instead of `con` blocks.
(First-order effects can be freely used in `hefty` blocks too, but if you
only have first-order effects then `con` blocks are more efficient)

#+begin_src elixir
defmodule Ex3 do

  defcon first() do
    _ <- TaggedWriter.tell(:foo, 100)
    return(:first)
  end

  defcon second() do
    _ <- TaggedWriter.tell(:foo, 200)
    return(:second)
  end

  defcon call_them() do
    _ <- first()
    second()
  end

  defhefty collect() do
    val <- call_them() |> TaggedWriter.listen()
    Freer.return(val)
  end

end

Ex3.collect()
|> TaggedWriter.Handler.run()
|> TaggedWriter.Algebra.run()
|> Lift.Algebra.run()
|> Run.eval()
#+end_src


** and the rest

Now that you've met a higher-order effect, and the `hefty` macros, we
can introduce `Throw` which is a first-order effect and `Catch` which
is a higher-order effect. There's special syntax in `hefty` for `Catch`

#+begin_src elixir
defmodule Ex4 do

  defcon will_it_throw(x) do
    if Integer.is_odd(x) do
      Throw.throw_error(:boom)
    else
      return(x * 2)
    end
  end

  defhefty safe_will_it_throw(x) do
    will_it_throw(x)
  catch
    :boom -> Hefty.return(:oops)
  end

  defhefty do_stuff_to_list(l) do
    FxList.fx_map(l, &safe_will_it_throw/1)
  end
end

Ex4.do_stuff_to_list([1,2,3,4,5])
|> Throw.Handler.run()
|> Catch.Algebra.run()
|> FxList.Algebra.run()
|> Lift.Algebra.run()
|> Run.eval()

#+end_src

** and and

There's also an `else` syntax in `hefty` for `with` style steps

#+begin_src elixir
defmodule Ex5 do

  defcon do_the_thing(k, x) do
    if Integer.is_odd(x) do
      return({:ok, x * 2})
    else
      return({k, x})
    end
  end

  defhefty process(a,b,c) do
    {:ok, ar} <- do_the_thing(:a, a)
    {:ok, br} <- do_the_thing(:b, b)
    {:ok, cr} <- do_the_thing(:c, c)
    return {:ok, [ar, br, cr]}
  else
    {step, _} -> return("failed at: #{step}")
  end
end

Ex5.process(1,2,3)
|> Else.Algebra.run()
|> Lift.Algebra.run()
|> Run.eval()

#+end_src

* more advanced effects

We've looked at some simple effects - Reader, Writer, State, some
slightly more complex higher-order effects like Catch and Else ...
now we'll have a brief look at some more advanced effects

** logging, replay and recovery

The EffectLogger is an advanced effect handler which observes all the
effects in a computation and records them in a structured log. The
log is serializable data, and can be written to and read from JSON.
More - the log contains all the serialized interpreted effect values,
so is enough to run the pure parts of the computation bypassing
effect handlers. If a computation failed part-way, the log can be used
to resume it with the exact values that caused the failure

#+begin_src elixir
defmodule Ex6 do
  defcon maybe_fail(version) do
    _ <- State.put(10)

    _ <- case version do
      :original ->             Throw.throw_error(:validation_failed)

      :patched ->                       return(:ok)
    end

    x <- State.get()
    return(x)
  end

  def builder(version) do
    maybe_fail(version)
    |> EffectLogger.Handler.run(EffectLogger.Log.new())
    |> Throw.Handler.run()
    |> State.Handler.run(0)
  end

end

builder1 = Ex6.builder(:original)
outcome1 =  Run.run(builder1)
outcome1.outputs[EffectLogger.Handler]

json1 = Jason.encode!(outcome1)

builder2 = Ex6.builder(:patched)
outcome2 = Run.rerun(builder2, Jason.decode!(json1))

outcome2 = (Ex6.maybe_fail(:patched)
  |> EffectLogger.Handler.run(EffectLogger.Log.new())
  |> Throw.Handler.run()
  |> State.Handler.run(0)
  |> Run.run())

outcome2.outputs[EffectLogger.Handler]
outcome2.result

#+end_src

** coroutines

Coroutines allow a computation to request a value from its caller

** serializable coroutines

Serialiable coroutines combine Coroutines with the EffectLogger, and
allow computations to be suspended waiting for a value, serialized, and
deserialized and resumed some time later



- mapper returns lists of changesets
- write changesets in bulk

- <insert a plain Elixir example>
#+begin_src elixir
defmodule Anon do
  defcon anonymize_user(user) do
    return(nil)
  end

  defcon anonymise_org(org) do
    return(nil)
  end


end


    defhefty anonymize_user(user) do
      changeset = User.anonymize_changeset(user)

      # Record the change (effect!)
      _ <- EctoFx.Changes.update(changeset)

      # Return the result of applying the changeset
      return(Ecto.Changeset.apply_changes(changeset))
    end

    defhefty anonymize_users_with_capture(user_ids) do
      # (effect!)
      users <- EctoFx.query(Queries, :find_users_by_ids, %{ids: user_ids})

      # capture all the EctoFx.Change.update calls (effect!)
      {anonymized_users, captured_changes} <-
        users
        |> FxList.fx_map(&anonymize_user/1)
        |> EctoFx.capture()

      return({anonymized_users, captured_changes})
    end
#+end_src

1. side-load parameters (reader pattern)
   -

3. accumulate state (state pattern)
   - accumulate without awkward accumulator patterns

4. coroutines keep the computation going

5. serializable coroutines!

6. debugging with the data that failed in prod


* Why would I want to use them
- You are fed up of side-effects being mixed inextricably with your domain logic
- You came across the functional-core/imperative-shell pattern, and it sounded
  great, but you found it hard to put into practice
- You would like to investigate generative testing a.k.a. property-based testing
- You really like coroutines
- You would like your domain model to be pure
- You would like to make your unit-tests run 10,000 times faster
  - Sona has ~30k tests - Freyja has ~500 and runs in 0.5s... Sona's tests could
    run in ~30s
- You would like to write functions without data-shuffling parameters
- You want all the logging for a multi-process backend operation to be gathered
  together
- You want to replay failed computations
- You want to write simple domain code without concerns for effect plumbing
- You want automatic logging without having to think about it


* How do they work
- There are several ways they can work
- We'll focus on Freyja, an Elixir library using a Freer monad
- It turns out the Freer monad has significant performance issues - so
  I'm working on another library, using

* What can they do


* What are the problems
** Performance
- Freyja is ~15x slower than a pure reduce
- creating Freer structs and maintaining the
  continuation queue dominate
** Skuld
- based on evidence-passing + final-encoding
  - represents the effects as "evidence" functions
  - doesn't create Freer structs - makes direct function calls
  - uses CPS for a wider range of effects, which causes some performance hit
  - ~4x slower than a pure reduce, ~4x faster than Freyja
  - Koka avoids this hit by using the type-system to identify when it can
    avoid creating continuations
