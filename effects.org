#+title: Algebraic Effects in Elixir

* The Problem

You've probably experienced these pain points:

** Slow tests

Domain logic calls =Repo.get!/2= directly. Most tests hits the database.
Property-based testing? No chance - 1000 iterations would take minutes.

** Context threading is painful

You need =tenant_id= in a function 8 levels deep. You add it as a parameter
to every function in the chain. Then you need =user_id=. Then =request_id=.
Your function signatures grow. Your call sites get noisy.

** Mocking is awkward

You create a behaviour, implement it twice, configure Mox, add
=Mox.verify_on_exit!= to every test. For every external dependency.
And the mocks don't compose - you end up with test setup that's longer
than the test itself.

** The functional-core/imperative-shell dream

You've heard it: "keep business logic pure, push I/O to the edges."

But how? Your domain logic /needs/ to query the database. It /needs/
to call external APIs. The pattern is easy at first, but gets hard as
call stacks get deeper, recursion bites, and dependencies compound.

* What if...

What if you could write domain logic that:

- Describes *what* it needs (fetch a record, save a change, get config)
- Without specifying *how* (which database, which API, real or fake)
- And the "how" was a deployment decision, not a coding decision?

That's what Algebraic Effects give you.

* The Payoff: Same Code, Different Backends

Here's real code from a todo app. This handler toggles a todo's completion:

#+begin_src elixir
defcomp handle(%ToggleTodo{id: id}) do
  # Get tenant context - could come from anywhere
  ctx <- Reader.ask(CommandContext)

  # Fetch the todo - doesn't specify how
  todo <- Repository.get_todo!(ctx.tenant_id, id)

  # Pure business logic
  changeset = Todo.changeset(todo, %{completed: not todo.completed})

  # Persist - doesn't specify where
  updated <- ChangesetPersist.update(changeset)

  {:ok, updated}
end
#+end_src

Notice what's /not/ here: no =Repo= calls, no GenServer, no process dictionary.

This is *domain logic*. It describes *what* needs to happen, not *how*.

** The handler swap

The same code runs against different backends:

#+begin_src elixir
# Production: real Ecto/Postgres
defp with_storage_handlers(comp, :database) do
  comp
  |> Query.with_handler(%{Repository => :direct})
  |> ChangesetPersist.Ecto.with_handler(Repo)
end

# Testing: pure in-memory storage
defp with_storage_handlers(comp, :in_memory) do
  comp
  |> Query.with_handler(%{Repository => {Repository.InMemory, :delegate}})
  |> InMemoryPersist.with_handler()
end
#+end_src

One line changes the storage backend. The domain handler doesn't change at all.

* The Testing Payoff

With pure handlers, property-based testing becomes practical:

#+begin_src elixir
property "ToggleTodo is self-inverse" do
  check all(cmd <- Generators.create_todo(), max_runs: 100) do
    {:ok, original} = create_and_get(cmd)

    # Toggle once
    {:ok, toggled} = Run.execute(%ToggleTodo{id: original.id}, mode: :in_memory)
    assert toggled.completed == not original.completed

    # Toggle again - should restore original state
    {:ok, restored} = Run.execute(%ToggleTodo{id: original.id}, mode: :in_memory)
    assert restored.completed == original.completed
  end
end
#+end_src

100 iterations. Milliseconds. No database setup, no cleanup, no flaky tests.

** Scaling up

Skuld's own test suite runs ~600 tests in 0.4 seconds.

Scale that up: a 30,000 test codebase would run in ~20 seconds.

Compare to a typical database-backed test suite: 5 minutes across 5 parallel
runners. That's *75x slower*.

Fast tests mean:
- Faster CI pipelines
- More property test iterations (find more bugs)
- Developers actually run tests locally
- Less flakiness (no network, no database state)

* How It Works: The 30-Second Version

Algebraic Effects split your code into three layers:

| Layer     | What it does                         | Example                         |
|-----------+--------------------------------------+---------------------------------|
| Pure      | Regular functions, no effects        | =String.upcase/1=               |
| Effectful | Describes effects without doing them | Your domain logic               |
| Handlers  | Actually performs the I/O            | Thin wrappers around Repo, HTTP |

Domain logic moves from "side-effecting" to "effectful".
It becomes pure - testable, composable, independent of infrastructure.

* The =comp= Macro

The =comp= macro is like =with=, but for effects:

#+begin_src elixir
comp do
  x <- Reader.ask()        # "I need some config"
  y <- State.get()         # "I need some state"
  return(x + y)            # "Here's my result"
end
|> Reader.with_handler(5)  # "Config is 5"
|> State.with_handler(10)  # "State is 10"
|> Comp.run!()             # "Go!"

#> 15
#+end_src

The =<-= arrow means "I need this effect interpreted". The value on the right
is a description of what you need. The handler decides how to provide it.

** =defcomp= for functions

#+begin_src elixir
defmodule MyApp do
  use Skuld.Syntax

  defcomp add_to_config(x) do
    y <- Reader.ask()
    return(x + y)
  end
end

MyApp.add_to_config(5)
|> Reader.with_handler(10)
|> Comp.run!()

#> 15
#+end_src

Effectful functions compose - call them from other =defcomp= functions,
and effects bubble up to wherever you install handlers.

* Building Blocks

Skuld provides several foundational effects. Think of these as
capabilities you can request from anywhere in your call stack.

** Reader: Config without parameter threading

Need =tenant_id= deep in a call stack? Don't thread it through every function:

#+begin_src elixir
# Deep in your code, just ask for it:
defcomp do_something() do
  ctx <- Reader.ask(TenantContext)
  # use ctx.tenant_id
end

# At the top level, provide it once:
do_something()
|> Reader.with_handler(%{tenant_id: "tenant_123"}, tag: TenantContext)
|> Comp.run!()
#+end_src

Multiple readers with different tags for different contexts.

** State: Accumulation without threading

Need to track state through a computation? Don't pass accumulators:

#+begin_src elixir
defcomp count_items(items) do
  _ <- State.put(0)

  FxList.fx_each(items, fn item ->
    comp do
      count <- State.get()
      _ <- State.put(count + 1)
      return(:ok)
    end
  end)

  State.get()  # return final count
end

count_items([1, 2, 3, 4, 5])
|> State.with_handler(0)
|> Comp.run!()

#> 5
#+end_src

** Writer: Logging from anywhere

Accumulate values from deep in a call stack:

#+begin_src elixir
defcomp process_with_audit(items) do
  FxList.fx_map(items, fn item ->
    comp do
      _ <- Writer.tell({:processed, item})
      return(item * 2)
    end
  end)
end

process_with_audit([1, 2, 3])
|> Writer.with_handler()
|> Comp.run!()

#> {[2, 4, 6], [{:processed, 1}, {:processed, 2}, {:processed, 3}]}
#+end_src

** Throw: Error handling that composes

#+begin_src elixir
defcomp maybe_fail(x) do
  if Integer.is_odd(x) do
    Throw.throw(:validation_failed)
  else
    return(x * 2)
  end
end

defcomp safe_process(x) do
  maybe_fail(x)
catch
  :validation_failed -> return(:skipped)
end
#+end_src

Errors propagate up the effectful call stack until caught.

* Pattern Matching with =else=

Like =with=, you can pattern match and handle failures:

#+begin_src elixir
defcomp process(a, b, c) do
  {:ok, ar} <- do_the_thing(:a, a)
  {:ok, br} <- do_the_thing(:b, b)
  {:ok, cr} <- do_the_thing(:c, c)
  return({:ok, [ar, br, cr]})
else
  {step, _} -> return({:error, "failed at: #{step}"})
end
#+end_src

* Advanced: Effect Logging and Replay

The EffectLogger records every effect in a computation:

#+begin_src elixir
defcomp maybe_fail(version) do
  _ <- State.put(10)
  _ <- case version do
    :original -> Throw.throw(:validation_failed)
    :patched -> return(:ok)
  end
  x <- State.get()
  return(x)
end

# Run with logging
{{:throw, :validation_failed}, log} =
  maybe_fail(:original)
  |> EffectLogger.with_logging()
  |> Throw.with_handler()
  |> State.with_handler(0)
  |> Comp.run()
  |> elem(0)

# The log captured everything up to the failure
# Fix the bug, replay from the exact failure point
#+end_src

The log is JSON-serializable. Write it to disk, inspect it, replay later.

** Cold resume across servers

#+begin_src elixir
# Server 1: computation suspends
log = EffectLogger.get_log(env) |> EffectLogger.Log.finalize()
json = Jason.encode!(log)
# Store in Redis/database...

# Server 2 (hours later, different node):
cold_log = Jason.decode!(json) |> EffectLogger.Log.from_json()

computation
|> EffectLogger.with_resume(cold_log, new_input)
|> Comp.run()
# Continues from exactly where it left off
#+end_src

* Advanced: Coroutines with Yield

Computations can suspend and request values from their caller:

#+begin_src elixir
defcomp interactive_sum() do
  x <- Yield.yield("Enter first number:")
  y <- Yield.yield("Enter second number:")
  return(x + y)
end

{:done, result, _yields, _env} =
  interactive_sum()
  |> Yield.with_handler()
  |> Yield.feed([10, 20])

#> result == 30
#+end_src

** Real example: LLM conversation loop

#+begin_src elixir
defcomp run() do
  config <- Reader.ask(ConversationComp)
  state <- State.get(ConversationComp)

  # Suspend, wait for user input
  user_message <- Yield.yield(:await_user_input)

  messages = state.messages ++ [%{role: "user", content: user_message}]
  result <- conversation_turn(messages, config.tools)

  case result do
    {:ok, response_text, final_messages, tool_executions} ->
      comp do
        _ <- Yield.yield(%{type: :response, text: response_text})
        _ <- State.put(ConversationComp, %{state | messages: final_messages})
        run()  # loop
      end

    {:error, reason} ->
      comp do
        _ <- Yield.yield(%{type: :error, reason: reason})
        run()
      end
  end
end
#+end_src

The conversation is a single computation that yields for input, calls the LLM,
yields responses, and loops forever. The caller drives it by resuming with values.

Try implementing this with GenServer - you'd need manual state machines,
explicit serialization, callback management. With effects, the computation
/is/ the state machine.

* The Cost

Algebraic Effects aren't free:

- *Performance overhead*: Skuld is ~4x slower than hand-threaded state for
  pure computation. For I/O-bound code (database, HTTP), this is negligible.

- *Learning curve*: It's a different way of thinking. The =comp= macro takes
  getting used to.

- *Team buy-in*: Everyone needs to understand the pattern, or you get
  a mix of effectful and side-effecting code.

The tradeoff is worth it when:
- Testability matters more than microseconds
- You have complex domain logic with many effects
- You want property-based testing
- You need effect logging for debugging

* When To Use Skuld

** Good fit
- I/O-bound services where testability matters
- Complex domain logic with many effects (DB, external APIs)
- When you want property-based testing of domain logic
- When you need effect logging for debugging/replay
- Multi-tenant systems (Reader effect for context)

** Maybe not
- CPU-bound computation where every microsecond counts
- Simple scripts with minimal side effects
- When the team isn't bought in

* Getting Started

1. *Start small*: Use Reader for configuration that you're currently threading
2. *Wrap one side-effect*: Create an effect signature for your Repo calls
3. *Write one property test*: See the testing benefits firsthand
4. *Expand gradually*: Add more effects as you see the value

#+begin_src elixir
# Add to mix.exs
{:skuld, "~> 0.1"}

# In your module
use Skuld.Syntax

defcomp my_first_effectful_function() do
  config <- Reader.ask()
  return(config.some_value)
end
#+end_src

* Summary

Algebraic Effects let you write code that describes *what* it needs,
not *how* to get it.

| Traditional                       | With Effects                       |
|-----------------------------------+------------------------------------|
| Domain logic calls Repo directly  | Domain logic requests effects      |
| Tests hit the database            | Tests use in-memory handlers       |
| Mocking requires behaviours + Mox | Swap handlers in one line          |
| Context threaded through params   | Reader effect provides it anywhere |

The "how" becomes a deployment decision, not a coding decision.

Your domain logic becomes pure. Side effects are pushed to the edge.
Testing becomes fast and deterministic.

#+begin_quote
"Make the effectful layer as large as possible,
 the side-effecting layer as thin as possible."
#+end_quote

* Resources

- Skuld: https://github.com/mccraigmccraig/skuld
- TodosMcp demo: https://github.com/mccraigmccraig/todos_mcp
- Live demo: https://todos-mcp-lu6h.onrender.com/

* Appendix: Setup for Live Examples

Use these aliases to run code examples in IEx:

#+begin_src elixir
alias Skuld.Comp
alias Skuld.Effects.Reader
alias Skuld.Effects.Writer
alias Skuld.Effects.State
alias Skuld.Effects.TaggedReader
alias Skuld.Effects.TaggedWriter
alias Skuld.Effects.TaggedState
alias Skuld.Effects.FxList
alias Skuld.Effects.Throw
alias Skuld.Effects.EffectLogger
require Integer
use Skuld.Syntax
#+end_src

* Appendix: How It Really Works

For those who want to understand the internals...

** Computations are functions

In Skuld, a computation is a function: =(env, continuation) -> {result, env}=

#+begin_src elixir
@type computation :: (env(), k() -> {result(), env()})
@type k :: (term(), env() -> {result(), env()})
#+end_src

** The environment tracks handlers

#+begin_src elixir
%Skuld.Comp.Env{
  evidence: %{sig => handler_fn},  # maps effect signatures to handlers
  state: %{key => value},          # effect state (Reader value, etc.)
  leave_scope: fn result, env -> {result, env} end
}
#+end_src

** Effect operations look up handlers

=Comp.effect(sig, args)= creates a computation that:
1. Looks up the handler for =sig= in the environment
2. Calls the handler with the operation args
3. Handler calls the continuation with the result

#+begin_src elixir
Reader.ask()
# Returns a computation that, when run:
# 1. Looks up Reader handler in env.evidence
# 2. Handler reads value from env.state
# 3. Handler calls continuation with that value
#+end_src

** The =comp= macro expands to chained calls

#+begin_src elixir
comp do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end

# Expands to:
Comp.chain(Reader.ask(), fn x ->
  Comp.chain(State.get(), fn y ->
    Comp.pure(x + y)
  end)
end)
#+end_src

** Effect signatures

Each effect defines operations as simple data structures:

#+begin_src elixir
defmodule Skuld.Effects.Reader do
  import Skuld.Comp.DefOp
  def_op(Ask)

  @sig __MODULE__
  def ask, do: Comp.effect(@sig, %Ask{})
end

defmodule Skuld.Effects.State do
  import Skuld.Comp.DefOp
  def_op(Get)
  def_op(Put, [:value])

  @sig __MODULE__
  def get, do: Comp.effect(@sig, %Get{})
  def put(v), do: Comp.effect(@sig, %Put{value: v})
end
#+end_src

Handlers interpret these operation structs however they like - that's
the "algebra" part: operations are just data until a handler gives them meaning.
