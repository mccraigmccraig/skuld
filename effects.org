#+title: Algebraic Effects in Elixir

* What are Algebraic Effects
- Allow *pure* programs to *describe* the side-effects they need
  without specifying how they are to be achieved
- A mechanism for descriptions of side-effects to be interpreted
  different ways
- The descriptions of side-effects are values in algebras formed
  by effect operations - similar to fields in arithmetic

* Why
- most programs have some pure functions and some side-effecting functions.
  The pure parts of the program are nicer to work with, and one would generally
  like to make as much of the program pure as possible
- Patterns such as functional-core/imperative-shell aim in this dirextion
  - the pattern is easy enough initially, but gets hard as call
    stacks get deeper and effect dependencies compound

- Algebraic Effects ntroduce some useful additional structure to programs
  1. fully pure functions remain
     - not much change here
  2. effectful functions are introduced
     - these are new, and most of the previously side-effecting functions in a
       program can be replaced with effectful functions. Effectful functions
       compose sequences of "effects" - which are function calls without any
       specified implementation. Implementation is provided by handlers, and
       can be changed for different contexts - e.g. a pure implementation to
       run in test contexts without a database
  3. impure effect handlers - the small parts of the program which truly need
     to be impure - because they do I/O or deal with randomness or async &c -
     are relegated to effect handlers
     - effect handlers are thin, easily testable, wrappers for side-effecting
        plumbing

* Where
- I/O bound programs struggling to manage complexity
- CSV importer
- combination of Reader / Writer pattern + CommandStreams

* The cost
- Freyja is slow - benchmarked at 17x slower than a simple state monad for
  in-memory computation
- Skuld is cobsiderably faster - 4x slower than a simple state monad
  - this seems reasonable for heavily I/O bound processes. A Benchmark with the
    user.csv importer shows an TBD times speedup because bulk data access is
    used
    - the thing that Algebraic Effects bring to the party is to make the bulk
      code as easy to write as the slow N+1 pattern code

* Aliases
- use these aliases to run all the code examples in IEx

#+begin_src elixir
alias Skuld.Comp
alias Skuld.Effects.Reader
alias Skuld.Effects.Writer
alias Skuld.Effects.State
alias Skuld.Effects.TaggedReader
alias Skuld.Effects.TaggedWriter
alias Skuld.Effects.TaggedState
alias Skuld.Effects.FxList
alias Skuld.Effects.Throw
alias Skuld.Effects.EffectLogger
require Integer
use Skuld.Syntax
#+end_src

* Effect signatures
- Here's a few simple foundational effect signatures
- each Effect signature defines one or more operations in the effect,
  and each operation signifies a request for some value without
  specfying how that value is to be obtained.
- in Skuld, each operation function creates a simple data structure,
  detailing the request, and wraps it in a computation using `Comp.effect`...

** Reader
pure functions can ask for a value anywhere in the call stack without
additional params
  - values can be system-wide config, or operation-specific config

#+begin_src elixir
defmodule Skuld.Effects.Reader do
  import Skuld.Comp.DefOp
  def_op(Ask)

  @sig __MODULE__
  def ask, do: Comp.effect(@sig, %Ask{})
end
#+end_src

** Writer
pure functions can accumluate values to a log from anywhere in the call stack,
without accumulator params
 - capture changes from deep within a call stack

#+begin_src elixir
defmodule Skuld.Effects.Writer do
  import Skuld.Comp.DefOp
  def_op(Tell, [:msg])

  @sig __MODULE__
  def tell(msg), do: Comp.effect(@sig, %Tell{msg: msg})
end
#+end_src

** State
pure functions can maniuplate a state variable from anywhere in the call stack,
without additional params
  - state could come from memory, database, cache - anywhere

#+begin_src elixir
defmodule Skuld.Effects.State do
  import Skuld.Comp.DefOp
  def_op(Get)
  def_op(Put, [:value])

  @sig __MODULE__
  def get, do: Comp.effect(@sig, %Get{})
  def put(v), do: Comp.effect(@sig, %Put{value: v})
end
#+end_src

** what does Comp.effect do ?
In Skuld, computations are represented as functions using continuation-passing
style (CPS). A computation is a function `(env, k) -> {result, env}` where:
- `env` is the environment containing handler evidence and state
- `k` is the continuation to call with the result

*** Computations as functions
Unlike Freyja's data-structure approach (Freer monads), Skuld represents
computations directly as functions. This avoids creating intermediate
structs and is significantly faster.

#+begin_src elixir
# A computation has this shape:
@type computation :: (env(), k() -> {result(), env()})
@type k :: (term(), env() -> {result(), env()})
#+end_src

*** The environment
The environment tracks installed handlers and their state:

#+begin_src elixir
%Skuld.Comp.Env{
  evidence: %{sig => handler_fn},  # maps effect signatures to handlers
  state: %{key => value},          # effect state (Reader value, Writer log, etc.)
  leave_scope: fn result, env -> {result, env} end  # cleanup chain
}
#+end_src

*** Comp.effect
- `Comp.effect(sig, args)` creates a computation that looks up the handler
  for `sig` in the environment and calls it with the operation args
- The handler is responsible for calling the continuation with the result

#+begin_src elixir
Reader.ask()
# Returns a computation function that, when run:
# 1. Looks up the Reader handler in env.evidence
# 2. Calls the handler with %Ask{}, env, and continuation k
# 3. Handler reads value from env.state and calls k.(value, env)

State.put(100)
# Returns a computation function that, when run:
# 1. Looks up the State handler in env.evidence
# 2. Calls the handler with %Put{value: 100}, env, and continuation k
# 3. Handler updates env.state and calls k.(:ok, new_env)
#+end_src


* How can we use effects
- some simple example Skuld code introducing how
  effects can be combined into programs

** we can "handle" an effect
- Handlers provide an interpreter for a particular effect's operations

#+begin_src elixir
Reader.ask()
|> Reader.with_handler(42)
|> Comp.run!()

#>   42

#+end_src

** We can sequence and compose effect operations
using values from previous effects to request new effects

We use the `&Comp.bind/2` function, which takes a computation,
and a function `(term -> computation)` of an interpreted effect value which
returns another computation - you'll see why the function is called `bind`
soon. We also use `&Comp.pure/1` which returns a pure value as a computation.

This computation requests two effects before returning a result:

#+begin_src elixir
Comp.bind(
  Reader.ask(),
  fn x ->
    Comp.bind(
      State.get(),
      fn y -> Comp.pure(x + y) end)
  end)
  |> Reader.with_handler(5)
  |> State.with_handler(10)
  |> Comp.run!()

#>   15

#+end_src

but this looks pretty ugly, and the nesting makes it hard to see what's going on...

** so, with a little macro sugar
This code is exactly equivalent to the previous sequence of nested
function calls, and makes the intent much clearer - the bound/matched
forms on the left of `<-` expressions end up as the anonymous function
parameters of the same name above, so the `comp` block behaves like
a generalized `with` - binding (hence the name) interpreted effect
values to variables at each step

#+begin_src elixir
comp do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end
|> Reader.with_handler(5)
|> State.with_handler(10)
|> Comp.run!()

#>    15

#+end_src


* So what's actually going on here
- let's trace through how Skuld executes a computation

#+begin_src elixir
c = comp do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end

# c is a function: (env, k) -> {result, env}
# The comp macro transforms this into nested Comp.bind calls
#+end_src

** the `comp` expression creates a computation function
The macro expands to nested `Comp.bind` calls:

#+begin_src elixir
# The comp block above is equivalent to:
Comp.bind(Reader.ask(), fn x ->
  Comp.bind(State.get(), fn y ->
    Comp.pure(x + y)
  end)
end)
#+end_src

** when we install handlers and run
each `with_handler` wraps the computation with handler evidence:

#+begin_src elixir
c
|> Reader.with_handler(5)   # installs Reader handler, sets reader value to 5
|> State.with_handler(10)   # installs State handler, sets state to 10
|> Comp.run!()              # runs the computation
#+end_src

** execution flow
1. `Comp.run!` calls the computation with an initial env and final continuation
2. First effect: `Reader.ask()` looks up the Reader handler in env
3. Handler reads value `5` from env.state and calls continuation with it
4. Continuation binds `x = 5` and proceeds to next effect
5. Second effect: `State.get()` looks up State handler
6. Handler reads value `10` from env.state and calls continuation with it
7. Continuation binds `y = 10` and evaluates `Comp.pure(x + y)`
8. `Comp.pure(15)` calls the final continuation with result `15`

** What have we seen
- the `comp` macro rearranges a `with`-like syntax into nested
  `bind` function calls
- program logic is captured in *pure* continuation functions
- pure program logic can use effect operations to make impure requests
- handlers can interpret those requests however they like
- unlike Freyja, Skuld uses direct function calls (CPS) instead of data structures

* getting more real-world

- introducing some new concepts

** defcomp
the `comp` macro makes sequencing effect requests into a computation easy.
`defcomp` does the same for functions

#+begin_src elixir
defmodule Ex1 do
  use Skuld.Syntax

  defcomp foo(x) do
    y <- Reader.ask()
    return(x + y)
  end

end

Ex1.foo(5)
|> Reader.with_handler(10)
|> Comp.run!()
#+end_src

** turtles

#+begin_src elixir
defmodule Ex2 do
  use Skuld.Syntax

  defcomp bar(x) do
    z <- Ex1.foo(x)
    return(z)
  end

end

Ex2.bar(5)
|> Reader.with_handler(10)
|> Comp.run!()
#+end_src

** higher and higher

So far, we've only seen "first order" effects - effects which *do not* take
computations as parameters... but there are higher-order effects which *do* take
computations as parameters too.

In Skuld, unlike Freyja, there's no distinction between first-order and
higher-order effects at the syntax level - `comp` and `defcomp` work for both.
This is because Skuld uses CPS which naturally handles higher-order effects.

#+begin_src elixir
defmodule Ex3 do
  use Skuld.Syntax

  defcomp first() do
    _ <- TaggedWriter.tell(:foo, 100)
    return(:first)
  end

  defcomp second() do
    _ <- TaggedWriter.tell(:foo, 200)
    return(:second)
  end

  defcomp call_them() do
    _ <- first()
    second()
  end

  defcomp collect() do
    # listen is a higher-order operation - it takes a computation as parameter
    val <- TaggedWriter.listen(:foo, call_them())
    return(val)
  end

end

Ex3.collect()
|> TaggedWriter.with_handler(:foo)
|> Comp.run!()
#+end_src


** and the rest

Now we can introduce `Throw` for error handling. There's special `catch`
syntax in `comp` blocks for catching thrown errors.

#+begin_src elixir
defmodule Ex4 do
  use Skuld.Syntax

  defcomp will_it_throw(x) do
    if Integer.is_odd(x) do
      Throw.throw(:boom)
    else
      return(x * 2)
    end
  end

  defcomp safe_will_it_throw(x) do
    will_it_throw(x)
  catch
    :boom -> return(:oops)
  end

  defcomp do_stuff_to_list(l) do
    FxList.fx_map(l, &safe_will_it_throw/1)
  end
end

Ex4.do_stuff_to_list([1,2,3,4,5])
|> Throw.with_handler()
|> Comp.run!()

#+end_src

** and and

There's also an `else` syntax in `comp` for `with` style pattern matching

#+begin_src elixir
defmodule Ex5 do
  use Skuld.Syntax

  defcomp do_the_thing(k, x) do
    if Integer.is_odd(x) do
      return({:ok, x * 2})
    else
      return({k, x})
    end
  end

  defcomp process(a,b,c) do
    {:ok, ar} <- do_the_thing(:a, a)
    {:ok, br} <- do_the_thing(:b, b)
    {:ok, cr} <- do_the_thing(:c, c)
    return {:ok, [ar, br, cr]}
  else
    {step, _} -> return("failed at: #{step}")
  end
end

Ex5.process(1,2,3)
|> Comp.run!()

#+end_src

* more advanced effects

We've looked at some simple effects - Reader, Writer, State, some
slightly more complex higher-order effects like Catch and Else ...
now we'll have a brief look at some more advanced effects

** logging, replay and recovery

The EffectLogger is an advanced effect handler which observes all the
effects in a computation and records them in a structured log. The
log is serializable data, and can be written to and read from JSON.
More - the log contains all the serialized interpreted effect values,
so is enough to run the pure parts of the computation bypassing
effect handlers. If a computation failed part-way, the log can be used
to resume it with the exact values that caused the failure

#+begin_src elixir
defmodule Ex6 do
  use Skuld.Syntax

  defcomp maybe_fail(version) do
    _ <- State.put(10)

    _ <- case version do
      :original -> Throw.throw(:validation_failed)
      :patched -> return(:ok)
    end

    x <- State.get()
    return(x)
  end

  def run_with_logging(version) do
    maybe_fail(version)
    |> EffectLogger.with_logging()  # must be innermost
    |> Throw.with_handler()
    |> State.with_handler(0)
    |> Comp.run()
  end

end

# Run the original (which throws)
{{:throw, :validation_failed}, log1} = Ex6.run_with_logging(:original) |> elem(0)

# The log captures all effects up to the throw
IO.inspect(log1)

# Run the patched version
{{:ok, 10}, log2} = Ex6.run_with_logging(:patched) |> elem(0)

# Can replay from a log to reproduce exact behavior
{replayed_result, _env} =
  Ex6.maybe_fail(:patched)
  |> EffectLogger.with_replay(log2)
  |> Comp.run()

#+end_src

** coroutines

Coroutines (via the Yield effect) allow a computation to suspend and
request a value from its caller

#+begin_src elixir
defmodule CoroutineEx do
  use Skuld.Syntax
  alias Skuld.Effects.Yield

  defcomp interactive_sum() do
    x <- Yield.yield("Enter first number:")
    y <- Yield.yield("Enter second number:")
    return(x + y)
  end
end

# Drive the coroutine by feeding inputs
alias Skuld.Effects.Yield

{:done, result, _yields, _env} =
  CoroutineEx.interactive_sum()
  |> Yield.with_handler()
  |> Yield.feed([10, 20])  # feed inputs to each yield

# result == 30
#+end_src

** serializable coroutines

Serialiable coroutines combine Coroutines with the EffectLogger, and
allow computations to be suspended waiting for a value, serialized, and
deserialized and resumed some time later



- mapper returns lists of changesets
- write changesets in bulk

- <insert a plain Elixir example>
#+begin_src elixir
defmodule Anon do
  use Skuld.Syntax

  defcomp anonymize_user(user) do
    return(nil)
  end

  defcomp anonymise_org(org) do
    return(nil)
  end
end


    defcomp anonymize_user(user) do
      changeset = User.anonymize_changeset(user)

      # Record the change (effect!)
      _ <- EctoFx.Changes.update(changeset)

      # Return the result of applying the changeset
      return(Ecto.Changeset.apply_changes(changeset))
    end

    defcomp anonymize_users_with_capture(user_ids) do
      # (effect!)
      users <- EctoFx.query(Queries, :find_users_by_ids, %{ids: user_ids})

      # capture all the EctoFx.Change.update calls (effect!)
      {anonymized_users, captured_changes} <-
        users
        |> FxList.fx_map(&anonymize_user/1)
        |> EctoFx.capture()

      return({anonymized_users, captured_changes})
    end
#+end_src

1. side-load parameters (reader pattern)
   -

3. accumulate state (state pattern)
   - accumulate without awkward accumulator patterns

4. coroutines keep the computation going

5. serializable coroutines!

6. debugging with the data that failed in prod


* Why would I want to use them
- You are fed up of side-effects being mixed inextricably with your domain logic
- You came across the functional-core/imperative-shell pattern, and it sounded
  great, but you found it hard to put into practice
- You would like to investigate generative testing a.k.a. property-based testing
- You really like coroutines
- You would like your domain model to be pure
- You would like to make your unit-tests run 10,000 times faster
  - Sona has ~30k tests - Freyja has ~500 and runs in 0.5s... Sona's tests could
    run in ~30s
- You would like to write functions without data-shuffling parameters
- You want all the logging for a multi-process backend operation to be gathered
  together
- You want to replay failed computations
- You want to write simple domain code without concerns for effect plumbing
- You want automatic logging without having to think about it


* How do they work
- There are several ways they can work
- Skuld uses an evidence-passing approach with continuation-passing style (CPS)
- Computations are functions, handlers are stored in an environment,
  and effects are dispatched by looking up handlers in the evidence map

* What can they do
- Reader: side-load configuration/context without parameter drilling
- Writer: accumulate logs/events from anywhere in the call stack
- State: thread mutable state through pure functions
- TaggedReader/Writer/State: multiple independent instances of the above
- Throw/Catch: structured error handling
- Yield: coroutines and suspendable computations
- FxList: effectful list operations (map, reduce, filter, etc.)
- Bracket: resource acquisition and cleanup (like try/finally)
- EffectLogger: logging, replay, and debugging of effect sequences

* What are the problems
** Performance
- There's inherent overhead in the effect dispatch mechanism
- Pure Elixir code is always faster than effectful code
- The tradeoff is worthwhile for I/O-bound code where the structure benefits
  outweigh the performance cost

** Skuld's approach
- Based on evidence-passing + continuation-passing style (CPS)
- Represents effects as "evidence" functions in an environment map
- Doesn't create data structures for each effect - makes direct function calls
- Uses CPS to support control effects (throw, catch, yield)
- ~4x slower than a pure reduce, ~4x faster than Freyja
- Koka (a research language) avoids some overhead by using the type-system
  to identify when continuations can be avoided
