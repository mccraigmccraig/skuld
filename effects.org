#+title: Algebraic Effects in Elixir

* Purity and sin

There are two difficult problems in computer science:

- naming things
- cache invalidation
- off by one errors

** There are two kinds of functions

*** Pure functions

We like pure functions because:

- they compose well
- they are predictable
- they are fast (algorithms permitting)

#+begin_src elixir
# Pure functions - output depends only on input
def add(a, b), do: a + b

def calculate_total(items) do
  Enum.reduce(items, 0, fn item, acc -> 
    acc + item.price * item.quantity 
  end)
end

def validate_email(email) do
  if String.contains?(email, "@"), do: {:ok, email}, else: {:error, :invalid}
end
#+end_src

*** Side-effecting functions

We don't like side-effecting functions because:

- they don't compose well
- they are slow... (not all side-effecting functions)
- they are unpredictable

On the other hand... we like side-effecting functions because:

- without them nothing actually happens

#+begin_src elixir
# Side-effecting functions - interact with the world
def save_user(user) do
  Repo.insert!(user)  # Hits the database
end

def fetch_weather(city) do
  HTTPoison.get!("https://api.weather.com/#{city}")  # Network call
end

def log_event(event) do
  Logger.info("Event: #{inspect(event)}")  # Writes to stdout/file
  :ok
end

def get_current_time() do
  DateTime.utc_now()  # Reads system clock
end

def increment_counter() do
  count = Process.get(:counter, 0)  # Read from process dictionary
  Process.put(:counter, count + 1)  # Write to process dictionary
  count + 1
end
#+end_src

*** Off by one

I am here to convince you of the existence of a 3rd class of functions:

**** Effectful functions

These inhabit a space somewhere between the pure functions and the
side-effecting functions.

Effectful functions allow a program to declare *what* effects it
wants to perform without specifying *how* they are to be performed.

The *how* can be decided upon later *without* changing code

#+begin_src elixir
# Effectful functions - describe what, not how
defcomp save_user(user) do
  ChangesetPersist.insert(user)  # "I need to persist this"
end

defcomp fetch_weather(city) do
  Http.get("https://api.weather.com/#{city}")  # "I need this HTTP response"
end

defcomp log_event(event) do
  _ <- Writer.tell({:event, event})  # "I want to record this"
  :ok
end

defcomp get_current_time() do
  Clock.now()  # "I need the current time"
end
#+end_src

The functions look similar to side-effecting functions, but they return
*descriptions* of effects, not results. Nothing happens until handlers
interpret those descriptions:

#+begin_src elixir
# Production: real database, real HTTP, real clock
save_user(user)
|> ChangesetPersist.Ecto.with_handler(Repo)
|> Comp.run!()

# Test: in-memory, deterministic
save_user(user)
|> ChangesetPersist.InMemory.with_handler()
|> Comp.run!()
#+end_src

* Problems & pains

** Slow tests

Domain logic calls =Repo.get!/2= directly. Most tests hits the database.
Property-based testing? No chance - 1000 iterations would take minutes.

** Context threading

You need =tenant_id= in a function 8 levels deep. You add it as a parameter
to every function in the chain. Then you need =user_id=. Then =request_id=.
Your function signatures grow. Your call sites get noisy.

** Mocking is awkward - and often depends on global state

Create a behaviour, implement it twice, configure Mox, add
=Mox.verify_on_exit!= to tests - for each external dependency.
And the mocks don't compose

** Functional-core/imperative-shell

"keep business logic pure, push I/O to the edges."

But how? Pure transformations are easy, but there is plenty of domain logic
which /needs/ to query the database, and /needs/ to call external APIs.
The pattern is easy at first, but gets complex as call stacks get deeper,
recursion bites, and dependencies compound.

* But...

What if you could write domain logic that:

- Describes *what* it needs (fetch a record, save a change, get config)
- But not *how* the request is granted (which database, which API, real or fake)
- And "how" becomes a deployment decision, not a coding decision?

This is what Algebraic Effects deliver.

* Same Code, Different Backends

Here's real code from an Algebraic Effects based implementation of the classic
todo app. This handler toggles a todo's completion:

#+begin_src elixir
defcomp handle(%ToggleTodo{id: id}) do
  # Get tenant context - could come from anywhere
  ctx <- Reader.ask(CommandContext)

  # Fetch the todo - doesn't specify how
  todo <- Repository.get_todo!(ctx.tenant_id, id)

  # Pure business logic
  changeset = Todo.changeset(todo, %{completed: not todo.completed})

  # Persist - doesn't specify where
  updated <- ChangesetPersist.update(changeset)

  {:ok, updated}
end
#+end_src

This is pure *domain logic*. It describes *what* needs to happen, not *how* -
it might /look/ side-effecting - but that's thanks to some macro sugar - it is
completely pure!

** Swap them handlers

The exact same code can be run against different backends:

#+begin_src elixir
# Production: real Ecto/Postgres
defp with_storage_handlers(comp, :database) do
  comp
  |> Query.with_handler(%{Repository => :direct})
  |> ChangesetPersist.Ecto.with_handler(Repo)
end

# Testing: pure in-memory storage
defp with_storage_handlers(comp, :in_memory) do
  comp
  |> Query.with_handler(%{Repository => {Repository.InMemory, :delegate}})
  |> InMemoryPersist.with_handler()
end
#+end_src

One line changes the storage backend. The domain handler doesn't change at all.

* Testing Payoff

With pure handlers, property-based testing becomes practical:

#+begin_src elixir
property "ToggleTodo is self-inverse" do
  check all(cmd <- Generators.create_todo(), max_runs: 100) do
    {:ok, original} = create_and_get(cmd)

    # Toggle once
    {:ok, toggled} = Run.execute(%ToggleTodo{id: original.id}, mode: :in_memory)
    assert toggled.completed == not original.completed

    # Toggle again - should restore original state
    {:ok, restored} = Run.execute(%ToggleTodo{id: original.id}, mode: :in_memory)
    assert restored.completed == original.completed
  end
end
#+end_src

100 iterations. Milliseconds. No database setup, no cleanup, no flaky tests.

** Scaling up

Skuld's own test suite runs ~600 tests in 0.4 seconds.

Scale that up: a 30,000 test codebase would run in ~20 seconds.

Compare to a typical database-backed test suite: 5 minutes across 5 parallel
runners. That's *75x slower*.

Fast tests mean:
- Faster CI pipelines
- More property test iterations (find more bugs)
- Developers actually run tests locally
- Less flakiness (no network, no database state)

* How It Works: The 30-Second Version

Algebraic Effects split your code into three layers:

| Layer     | What it does                         | Example                         |
|-----------+--------------------------------------+---------------------------------|
| Pure      | Regular functions, no effects        | =String.upcase/1=               |
| Effectful | Describes effects without doing them | Your domain logic               |
| Handlers  | Actually performs the I/O            | Thin wrappers around Repo, HTTP |

Domain logic moves from "side-effecting" to "effectful".
It becomes pure - testable, composable, independent of infrastructure.

* The =comp= Macro

The =comp= macro is like =with=, but for effects:

#+begin_src elixir
comp do
  x <- Reader.ask()        # "I need some config"
  y <- State.get()         # "I need some state"
  return(x + y)            # "Here's my result"
end
|> Reader.with_handler(5)  # "Config is 5"
|> State.with_handler(10)  # "State is 10"
|> Comp.run!()             # "Go!"

#> 15
#+end_src

The =<-= arrow means "I need this effect interpreted". The value on the right
is a description of what you need. The handler decides how to provide it.

** =defcomp= for functions

#+begin_src elixir
defmodule MyApp do
  use Skuld.Syntax

  defcomp add_to_config(x) do
    y <- Reader.ask()
    return(x + y)
  end
end

MyApp.add_to_config(5)
|> Reader.with_handler(10)
|> Comp.run!()

#> 15
#+end_src

Effectful functions compose - call them from another =defcomp= functions,
and effects bubble up to wherever you install handlers.

* Building Blocks

Skuld provides several foundational effects. Think of these as
capabilities you can request from anywhere in your call stack.

** Reader: Config without parameter threading

Need =tenant_id= deep in a call stack? Don't thread it through every function:

#+begin_src elixir
defmodule DoSomething do
  # Deep in your code, just ask for it:
  defcomp do_something() do
    %{tenant_id: tenant_id} <- Reader.ask(__MODULE__)
    {:pk, tenant_id}
  end
end

# At the top level, provide it once:
DoSomething.do_something()
|> Reader.with_handler(%{tenant_id: "tenant_123"}, tag: DoSomething)
|> Comp.run!()
#+end_src

Multiple readers with different tags for different contexts.

** State: Accumulation without threading

Need to track state through a computation? No need for accumulator parameters:

#+begin_src elixir
defmodule CountItems do
  defcomp count_items(items) do

    _ <- FxList.fx_each(items, fn item ->
      comp do
        count <- State.modify(& &1+1)
        :ok
      end
    end)

    State.get()  # return final count
  end
end

CountItems.count_items([1, 2, 3, 4, 5])
|> State.with_handler(0)
|> Comp.run!()

#> 5
#+end_src

** Writer: Structured logging from anywhere

Accumulate values from deep in a call stack:

#+begin_src elixir
defmodule ProcessWithAudit do
  defcomp process_with_audit(items) do
    FxList.fx_map(items, fn item ->
      comp do
        _ <- Writer.tell({:processed, item})
        return(item * 2)
      end
    end)
  end
end

ProcessWithAudit.process_with_audit([1, 2, 3])
|> Writer.with_handler([], output: fn r, log -> {r, log} end)
|> Comp.run!()

#> {[2, 4, 6], [{:processed, 1}, {:processed, 2}, {:processed, 3}]}
#+end_src

** Throw: Error handling that composes

#+begin_src elixir
defmodule MaybeFail do
  defcomp maybe_fail(x) do
    if Integer.is_odd(x) do
      Throw.throw(:validation_failed)
    else
      x * 2
    end
  end

  defcomp safe_process(x) do
    maybe_fail(x)
  catch
    {Throw, :validation_failed} -> :skipped
  end
end
#+end_src

Errors propagate up the effectful call stack until caught.

* Pattern Matching with =else=

Like =with=, you can pattern match and handle failures:

#+begin_src elixir
defmodule Process do
  defcomp process(a, b, c) do
    {:ok, ar} <- do_the_thing(:a, a)
    {:ok, br} <- do_the_thing(:b, b)
    {:ok, cr} <- do_the_thing(:c, c)
    {:ok, [ar, br, cr]}
  else
    {step, _} -> {:error, "failed at: #{step}"}
  end
end
#+end_src

* Advanced: Effect Logging and Replay

The EffectLogger records every effect in a computation:

#+begin_src elixir
defmodule MaybeFail do
  defcomp maybe_fail(version) do
    _ <- State.put(10)
    _ <- case version do
           :original -> Throw.throw(:validation_failed)
           :patched -> :ok
         end
    x <- State.get()
    x
  end
end

# Run with logging
{%Skuld.Comp.Throw{error: :validation_failed}, log} = (
  MaybeFail.maybe_fail(:original)
  |> EffectLogger.with_logging()
  |> Throw.with_handler()
  |> State.with_handler(0)
  |> Comp.run()
  |> elem(0)
)

# The log captured everything up to the failure
# Fix the bug, replay from the exact failure point
#+end_src

The log is JSON-serializable. Write it to disk, inspect it, replay later.

** Cold resume across servers

#+begin_src elixir
# Server 1: computation suspends
log = EffectLogger.get_log(env) |> EffectLogger.Log.finalize()
json = Jason.encode!(log)
# Store in Redis/database...

# Server 2 (hours later, different node):
cold_log = Jason.decode!(json) |> EffectLogger.Log.from_json()

computation
|> EffectLogger.with_resume(cold_log, new_input)
|> Comp.run()
# Continues from exactly where it left off
#+end_src

* Advanced: Coroutines with Yield

Computations can suspend and request values from their caller:

#+begin_src elixir
defmodule InteractiveSum do
  defcomp interactive_sum() do
    x <- Yield.yield("Enter first number:")
    y <- Yield.yield("Enter second number:")
    x + y
  end
end

{:done, result, _yields, _env} = (
  InteractiveSum.interactive_sum()
  |> Yield.with_handler()
  |> Yield.feed([10, 20])
)

#> result == 30
#+end_src

** Real example: LLM conversation loop

#+begin_src elixir
defcomp run() do
  config <- Reader.ask(ConversationComp)
  state <- State.get(ConversationComp)

  # Suspend, wait for user input
  user_message <- Yield.yield(:await_user_input)

  messages = state.messages ++ [%{role: "user", content: user_message}]
  result <- conversation_turn(messages, config.tools)

  case result do
    {:ok, response_text, final_messages, tool_executions} ->
      comp do
        _ <- Yield.yield(%{type: :response, text: response_text})
        _ <- State.put(ConversationComp, %{state | messages: final_messages})
        run()  # loop
      end

    {:error, reason} ->
      comp do
        _ <- Yield.yield(%{type: :error, reason: reason})
        run()
      end
  end
end
#+end_src

The conversation is a single computation that yields for input, calls the LLM,
yields responses, and loops forever. The caller drives it by resuming with values.

The computation /is/ the state machine!

* The Cost

Algebraic Effects aren't free:

- *Performance overhead*: Skuld orchestration is ~4x slower than a simple state
  monad. If your program did nothing but effect orchestration, that would be
  significant - but if your program is doing I/O and actual computation it's
  small beer

- *Learning curve*: It's a different way of thinking. The =comp= macro takes
  getting used to.

The tradeoff is worth it when:
- Testability matters more than microseconds
- You have complex domain logic with many effects
- You want property-based testing
- You need effect logging for debugging

* When To Use Skuld

** Good fit
- I/O-bound services where testability matters
- Complex domain logic with many effects (DB, external APIs)
- When you want property-based testing of domain logic
- When you need effect logging for debugging/replay

** Maybe not
- CPU-bound computation where every microsecond counts
- Simple scripts with minimal side effects
- When the team isn't bought in

* Summary

Algebraic Effects let you write code that describes *what* it needs,
not *how* to get it.

| Traditional                       | With Effects                       |
|-----------------------------------+------------------------------------|
| Domain logic calls Repo directly  | Domain logic requests effects      |
| Tests hit the database            | Tests use in-memory handlers       |
| Mocking requires behaviours + Mox | Swap handlers in one line          |
| Context threaded through params   | Reader effect provides it anywhere |

The "how" becomes a deployment decision, not a coding decision.

Your domain logic becomes pure. Side effects are pushed to the edge.
Testing becomes fast and deterministic.

#+begin_quote
"Make the effectful layer as large as possible,
 the side-effecting layer as thin as possible."
#+end_quote

* Resources

- Skuld: https://github.com/mccraigmccraig/skuld
- TodosMcp demo: https://github.com/mccraigmccraig/todos_mcp
- Live demo: https://todos-mcp-lu6h.onrender.com/

* Appendix: Setup for Live Examples

Use these aliases to run code examples in IEx:

#+begin_src elixir
alias Skuld.Comp
alias Skuld.Effects.Reader
alias Skuld.Effects.Writer
alias Skuld.Effects.State
alias Skuld.Effects.TaggedReader
alias Skuld.Effects.TaggedWriter
alias Skuld.Effects.TaggedState
alias Skuld.Effects.FxList
alias Skuld.Effects.Throw
alias Skuld.Effects.EffectLogger
alias Skuld.Effects.Yield
require Integer
use Skuld.Syntax
#+end_src

* Appendix: How It Really Works

For those who want to understand the internals...

** Computations are functions

In Skuld, a computation is a function: =(env, continuation) -> {result, env}=

#+begin_src elixir
@type computation :: (env(), k() -> {result(), env()})
@type k :: (term(), env() -> {result(), env()})
#+end_src

** The environment tracks handlers

#+begin_src elixir
%Skuld.Comp.Env{
  evidence: %{sig => handler_fn},  # maps effect signatures to handlers
  state: %{key => value},          # effect state (Reader value, etc.)
  leave_scope: fn result, env -> {result, env} end
}
#+end_src

** Effect operations look up handlers

=Comp.effect(sig, args)= creates a computation that:
1. Looks up the handler for =sig= in the environment
2. Calls the handler with the operation args
3. Handler calls the continuation with the result

#+begin_src elixir
Reader.ask()
# Returns a computation that, when run:
# 1. Looks up Reader handler in env.evidence
# 2. Handler reads value from env.state
# 3. Handler calls continuation with that value
#+end_src

** The =comp= macro expands to chained calls

#+begin_src elixir
comp do
  x <- Reader.ask()
  y <- State.get()
  return(x + y)
end

# Expands to:
Comp.bind(Reader.ask(), fn x ->
  Comp.bind(State.get(), fn y ->
    Comp.pure(x + y)
  end)
end)
#+end_src

** Effect signatures

Each effect defines operations as simple data structures:

#+begin_src elixir
defmodule Skuld.Effects.Reader do
  import Skuld.Comp.DefOp
  def_op(Ask)

  @sig __MODULE__
  def ask, do: Comp.effect(@sig, %Ask{})
end

defmodule Skuld.Effects.State do
  import Skuld.Comp.DefOp
  def_op(Get)
  def_op(Put, [:value])

  @sig __MODULE__
  def get, do: Comp.effect(@sig, %Get{})
  def put(v), do: Comp.effect(@sig, %Put{value: v})
end
#+end_src

Handlers interpret these operation structs however they like - that's
the "algebra" part: operations are just data until a handler gives them meaning.
